import mongoose from 'mongoose';
const { Schema, model } = mongoose;

const NotificationSchema = new Schema({
  // User identification with optimized indexing
  userId: { 
    type: String, 
    required: true,
    index: true,
    maxlength: 50
  },
  
  // Notification content with length limits
  title: { 
    type: String, 
    required: true,
    maxlength: 200,
    trim: true
  },
  
  body: { 
    type: String, 
    required: true,
    maxlength: 1000,
    trim: true
  },
  
  // Categorization for better filtering and analytics
  type: { 
    type: String, 
    default: 'general',
    enum: [
      'general', 'security', 'marketing', 'system', 
      'urgent', 'promotional', 'reminder', 'social',
      'payment', 'order', 'message', 'alert'
    ],
    index: true
  },
  
  // Delivery channels with validation
  channels: [{
    type: String,
    enum: ['email', 'push', 'sms', 'mobile', 'webhook', 'in-app'],
    required: true
  }],
  
  // Priority for queue processing
  priority: {
    type: Number,
    default: 3,
    min: 1, // Highest priority
    max: 5, // Lowest priority
    index: true
  },
  
  // Enhanced metadata
  data: {
    // Action data for deep linking
    actionUrl: { type: String, maxlength: 500 },
    actionType: { 
      type: String, 
      enum: ['redirect', 'modal', 'api_call', 'none'],
      default: 'none'
    },
    
    // Campaign/batch tracking
    campaignId: { type: String, maxlength: 50, index: true },
    batchId: { type: String, maxlength: 50, index: true },
    
    // Template information
    templateId: { type: String, maxlength: 50 },
    templateVersion: { type: String, maxlength: 20 },
    
    // Personalization data (limited size)
    variables: { 
      type: Map, 
      of: Schema.Types.Mixed,
      validate: {
        validator: function(v) {
          return JSON.stringify(v).length <= 2048; // 2KB limit
        },
        message: 'Variables data exceeds 2KB limit'
      }
    },
    
    // Additional metadata
    source: { type: String, maxlength: 100 },
    category: { type: String, maxlength: 50 },
    tags: [{ type: String, maxlength: 50 }]
  },
  
  // Status tracking with detailed states
  status: {
    type: String,
    default: 'pending',
    enum: [
      'pending', 'queued', 'sending', 'sent', 
      'delivered', 'failed', 'cancelled', 'expired'
    ],
    index: true
  },
  
  // Read/interaction tracking
  seen: { 
    type: Boolean, 
    default: false,
    index: true
  },
  
  seenAt: { 
    type: Date,
    index: { sparse: true } // Only index non-null values
  },
  
  clicked: { 
    type: Boolean, 
    default: false 
  },
  
  clickedAt: { 
    type: Date,
    index: { sparse: true }
  },
  
  // Delivery tracking per channel
  delivery: {
    email: {
      status: { 
        type: String, 
        enum: ['pending', 'sent', 'delivered', 'bounced', 'failed'],
        default: 'pending'
      },
      sentAt: Date,
      deliveredAt: Date,
      error: String,
      messageId: String // Provider message ID
    },
    
    push: {
      status: { 
        type: String, 
        enum: ['pending', 'sent', 'delivered', 'failed'],
        default: 'pending'
      },
      sentAt: Date,
      deliveredAt: Date,
      error: String,
      clickCount: { type: Number, default: 0 }
    },
    
    sms: {
      status: { 
        type: String, 
        enum: ['pending', 'sent', 'delivered', 'failed'],
        default: 'pending'
      },
      sentAt: Date,
      deliveredAt: Date,
      error: String,
      messageId: String,
      cost: Number // SMS cost tracking
    },
    
    mobile: {
      status: { 
        type: String, 
        enum: ['pending', 'sent', 'delivered', 'failed'],
        default: 'pending'
      },
      sentAt: Date,
      deliveredAt: Date,
      error: String,
      platform: { type: String, enum: ['ios', 'android'] },
      notificationId: String
    }
  },
  
  // Scheduling
  scheduledFor: { 
    type: Date,
    index: { sparse: true }
  },
  
  // TTL for automatic cleanup
  expiresAt: { 
    type: Date,
    index: { expireAfterSeconds: 0 }
  },
  
  // Retry mechanism
  retryCount: { 
    type: Number, 
    default: 0,
    max: 5
  },
  
  maxRetries: { 
    type: Number, 
    default: 3,
    max: 5
  },
  
  nextRetryAt: {
    type: Date,
    index: { sparse: true }
  },
  
  // Performance tracking
  processingTime: Number, // Time taken to process in ms
  queueTime: Number, // Time spent in queue in ms
  
  // Soft delete for compliance
  isDeleted: { 
    type: Boolean, 
    default: false,
    index: true
  },
  
  deletedAt: {
    type: Date,
    index: { sparse: true }
  }
  
}, { 
  timestamps: true,
  // Optimizations
  versionKey: false,
  minimize: false,
  // Collection options
  collection: 'notifications',
  // Read preference for analytics queries
  read: 'secondaryPreferred'
});

// Compound indexes for common query patterns
NotificationSchema.index({ userId: 1, createdAt: -1 }); // User timeline
NotificationSchema.index({ userId: 1, seen: 1, createdAt: -1 }); // Unread notifications
NotificationSchema.index({ userId: 1, type: 1, createdAt: -1 }); // Filter by type
NotificationSchema.index({ status: 1, scheduledFor: 1 }); // Scheduled notifications
NotificationSchema.index({ status: 1, nextRetryAt: 1 }); // Retry processing
NotificationSchema.index({ campaignId: 1, createdAt: -1 }); // Campaign analytics
NotificationSchema.index({ batchId: 1, status: 1 }); // Batch processing
NotificationSchema.index({ priority: 1, createdAt: 1 }); // Queue processing
NotificationSchema.index({ type: 1, createdAt: -1 }); // Type-based queries
NotificationSchema.index({ isDeleted: 1, createdAt: -1 }); // Active notifications

// TTL index for automatic cleanup of old notifications (90 days)
NotificationSchema.index({ createdAt: 1 }, { expireAfterSeconds: 7776000 });

// Partial indexes for better performance
NotificationSchema.index(
  { userId: 1, seen: 1 }, 
  { partialFilterExpression: { seen: false } }
); // Only unread notifications

NotificationSchema.index(
  { userId: 1, status: 1 }, 
  { partialFilterExpression: { status: { $in: ['pending', 'queued', 'sending'] } } }
); // Only active processing

// Virtual fields
NotificationSchema.virtual('isExpired').get(function() {
  return this.expiresAt && this.expiresAt < new Date();
});

NotificationSchema.virtual('needsRetry').get(function() {
  return this.status === 'failed' && 
         this.retryCount < this.maxRetries && 
         this.nextRetryAt && 
         this.nextRetryAt <= new Date();
});

NotificationSchema.virtual('deliverySuccess').get(function() {
  const channels = ['email', 'push', 'sms', 'mobile'];
  return channels.some(channel => 
    this.delivery[channel] && 
    ['delivered', 'sent'].includes(this.delivery[channel].status)
  );
});

// Instance methods
NotificationSchema.methods.markAsSeen = async function() {
  if (!this.seen) {
    this.seen = true;
    this.seenAt = new Date();
    await this.save();
  }
  return this;
};

NotificationSchema.methods.markAsClicked = async function() {
  if (!this.clicked) {
    this.clicked = true;
    this.clickedAt = new Date();
    await this.save();
  }
  return this;
};

NotificationSchema.methods.incrementRetry = function() {
  this.retryCount += 1;
  // Exponential backoff: 1min, 5min, 15min, 30min, 60min
  const delays = [60000, 300000, 900000, 1800000, 3600000];
  const delay = delays[Math.min(this.retryCount - 1, delays.length - 1)];
  this.nextRetryAt = new Date(Date.now() + delay);
  return this;
};

NotificationSchema.methods.updateDeliveryStatus = function(channel, status, metadata = {}) {
  if (!this.delivery[channel]) {
    this.delivery[channel] = {};
  }
  
  this.delivery[channel].status = status;
  
  if (status === 'sent') {
    this.delivery[channel].sentAt = new Date();
  } else if (status === 'delivered') {
    this.delivery[channel].deliveredAt = new Date();
  } else if (status === 'failed') {
    this.delivery[channel].error = metadata.error;
  }
  
  // Update metadata
  Object.assign(this.delivery[channel], metadata);
  
  return this;
};

NotificationSchema.methods.softDelete = async function() {
  this.isDeleted = true;
  this.deletedAt = new Date();
  await this.save();
  return this;
};

// Static methods for common operations
NotificationSchema.statics.findUnreadByUser = function(userId, limit = 50, skip = 0) {
  return this.find({ 
    userId, 
    seen: false, 
    isDeleted: false,
    $or: [
      { expiresAt: { $exists: false } },
      { expiresAt: { $gt: new Date() } }
    ]
  })
  .sort({ priority: 1, createdAt: -1 })
  .limit(limit)
  .skip(skip)
  .lean();
};

NotificationSchema.statics.findByUserAndType = function(userId, type, limit = 20) {
  return this.find({ 
    userId, 
    type, 
    isDeleted: false 
  })
  .sort({ createdAt: -1 })
  .limit(limit)
  .lean();
};

NotificationSchema.statics.findPendingForProcessing = function(limit = 100) {
  return this.find({
    status: { $in: ['pending', 'queued'] },
    isDeleted: false,
    $or: [
      { scheduledFor: { $exists: false } },
      { scheduledFor: { $lte: new Date() } }
    ]
  })
  .sort({ priority: 1, createdAt: 1 })
  .limit(limit);
};

NotificationSchema.statics.findForRetry = function(limit = 50) {
  return this.find({
    status: 'failed',
    retryCount: { $lt: mongoose.Schema.path('maxRetries').default() },
    nextRetryAt: { $lte: new Date() },
    isDeleted: false
  })
  .sort({ nextRetryAt: 1 })
  .limit(limit);
};

NotificationSchema.statics.getAnalytics = function(userId, startDate, endDate) {
  const pipeline = [
    {
      $match: {
        userId,
        createdAt: { $gte: startDate, $lte: endDate },
        isDeleted: false
      }
    },
    {
      $group: {
        _id: '$type',
        total: { $sum: 1 },
        seen: { $sum: { $cond: ['$seen', 1, 0] } },
        clicked: { $sum: { $cond: ['$clicked', 1, 0] } },
        avgProcessingTime: { $avg: '$processingTime' }
      }
    }
  ];
  
  return this.aggregate(pipeline);
};

NotificationSchema.statics.bulkMarkAsSeen = function(userId, notificationIds) {
  return this.updateMany(
    { 
      userId, 
      _id: { $in: notificationIds },
      seen: false 
    },
    { 
      $set: { 
        seen: true, 
        seenAt: new Date() 
      } 
    }
  );
};

// Pre-save middleware
NotificationSchema.pre('save', function(next) {
  // Set expiry if not set (default 30 days)
  if (!this.expiresAt) {
    this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  }
  
  // Initialize delivery tracking for specified channels
  if (this.isNew && this.channels) {
    this.channels.forEach(channel => {
      if (!this.delivery[channel]) {
        this.delivery[channel] = { status: 'pending' };
      }
    });
  }
  
  next();
});

// Post-save middleware for real-time updates
NotificationSchema.post('save', async function(doc) {
  // Emit real-time event for new notifications
  if (doc.isNew && !doc.isDeleted) {
    // You can integrate with Socket.io or other real-time systems here
    // Example: socketService.emitToUser(doc.userId, 'new_notification', doc);
  }
});

export default model('Notification', NotificationSchema);








// Statics = Custom functions on the Model (class-level).

// Methods = Custom functions on the Document (instance-level).

// Built-in functions (like findOne, save) come from Mongoose itself.

// You can add your own alongside them.

// So yes, it’s totally valid and recommended to define .methods and .statics “outside” the schema definition block. They extend the functionality of your model beyond Mongoose’s built-ins.
// we defining the methods of the notificationSchema outside the schema? is it valid? also statics. let us make userdefined function of any model but we have some model funtions too like findOne and etc